1. Our maze generator works by using the recursive depth-first search algorithm. To make sure that this is possible we needed to implement a "Cell" class for the data type of each part of the maze and a "Grid" class which is the logic of the algorithm. The design works by creating an ArrayList of Cells and a Stack of cells. It begins by filling the ArrayList with 2 dimension cells. It then chooses an intial cell, marks it as visited then pushes it to the stack. While the stack is not empty it will execute the following; pop a cell from the stack and make it a current cell, choose an unvisited neighbour, remove the wall between current cell and chosen cell and finally it marks the chosen cell as visited and pushes it to the stack.

2. The second OOP explanation is about the win & loss conditions of the game. The game can be won by two conditions. This is when all three monsters have been killed or by calling the cheat code ("c"). If the cheat code is used the game only requires one monster to be killed. The way that the win is measured is that the Main class calls the GameLogic class. In this class there is a if statement in the heroMove() method. Every move the game checks whether the hero has killed all monsters (it iterates through each monster's attributes, checking whether their alive state is alive or dead), if they have then the game will use the method in the GameUI class and will print out that the hero has won. Else the game will continues as normal if this condition is not met.

	Similar to this there is also a loss condition. If the hero touches a monster and does not have a reserved powerup (kept in his class) the game will immediate end (break the while loop). At this point the game will print to the user to the user that they have lost the game.
